Big O performance of common functions of different Algorithms

Algorithm | Time Complexity | Space Complexity |

----------------------------------|---------------------------------------|------------------|

Binary Search | O(log n) | O(1) |

Bubble Sort | O(n^2) | O(1) |

Selection Sort | O(n^2) | O(1) |

Insertion Sort | O(n^2) | O(1) |

Merge Sort | O(n log n) | O(n) |

Quick Sort | O(n^2) (worst-case)) | O(log n) |

Hash Table | O(n) | O(n) |

Binary Heap | O(log n) | O(n) |

Binary Tree | O(n) | O(n) |

Breadth-First Search | O(V + E) [V = vertices, E = edges] | O(V) |

Depth-First Search | O(V + E) [V = vertices, E = edges] | O(V) |

Dijkstra's Algorithm | O(V^2) | O(V) |

Bellman-Ford Algorithm | O(VE) [V = vertices, E = edges] | O(V) |

Floyd-Warshall Algorithm | O(V^3) | O(V^2) |

Topological Sort | O(V + E) [V = vertices, E = edges] | O(V) |

Linear Search | O(n) | O(1) |

Counting Sort | O(n + k) | O(n + k) |

Radix Sort | O(d(n + k)) | O(n + k) |

Tries | O(nk) | O(n + k) |

Binary Search Tree | O(n) | O(n) |

AVL Tree | O(log n) | O(n) |

Red Black Tree | O(log n) | O(n) |

Knapsack Problem | O(nW) n=no. of items, w=capacity | O(nW) |

Longest Common Subsequence | O(nm) | O(nm) |

Prim's Minimum Spanning Tree | O(V + E) [V = vertices, E = edges] | O(V + E) |

Kruskal's Minimum Spanning Tree | O(ElogV) | O(V + E) |

Heap Sort | O(nlog n) | O(1) |

A* Search | O(bd) b=branching factor and d= depth | O(bd)

#bigO #complexity #algorithms 